============================= test session starts =============================
platform win32 -- Python 3.13.3, pytest-9.0.2, pluggy-1.6.0
rootdir: P:\projects\AIRS
plugins: cov-7.0.0, mock-3.15.1, anyio-4.11.0
collected 2 items

app\tests\test_framework_coverage.py FF                                  [100%]

================================== FAILURES ===================================
_______________________ test_mitre_coverage_calculation _______________________

    def test_mitre_coverage_calculation():
        """Test that MITRE coverage metrics are calculated correctly."""
        # Setup mock service
        service = AssessmentService(MagicMock())
    
        # Create findings that map to MITRE techniques
        # tl_01 maps to T1059, T1071
        findings = [
            Finding(
                id="f1",
                title="Test Gap",
                severity=Severity.HIGH,
                question_id="tl_01",
                domain_name="Telemetry",
                description="Test"
            )
        ]
    
        # Calculate mapping
>       result = service._build_framework_mapping(findings)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app\tests\test_framework_coverage.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.services.assessment.AssessmentService object at 0x0000020CB4B0D7F0>
findings = [<Finding(id=f1, title=Test Gap, severity=Severity.HIGH)>]

    def _build_framework_mapping(self, findings: List[Finding]) -> Dict[str, Any]:
        """Build framework mapping data (MITRE ATT&CK, CIS Controls, OWASP)."""
        from app.core.frameworks import (
            get_all_framework_refs,
            get_technique_coverage,
            get_cis_coverage_summary,
            MITRE_TECHNIQUES,
            CIS_CONTROLS,
        )
    
        mapped_findings = []
        for f in findings:
            refs = get_all_framework_refs(f.question_id) if f.question_id else {}
    
            mapped_findings.append({
                "finding_id": f.id,
                "title": f.title,
                "severity": get_severity_value(f.severity),
                "domain": f.domain_name,
                "mitre_refs": refs.get("mitre", []),
                "cis_refs": refs.get("cis", []),
                "owasp_refs": refs.get("owasp", []),
                "impact_score": 5,  # Default impact score
            })
    
        # Build coverage stats based on findings (gaps indicate missing controls)
        question_ids = [f.question_id for f in findings if f.question_id]
    
        # Simple coverage calculation
        # In a full implementation, we'd track which controls are implemented
        mitre_coverage = get_technique_coverage(question_ids) if question_ids else {}
        cis_coverage = get_cis_coverage_summary(question_ids) if question_ids else {}
    
        return {
            "findings": mapped_findings,
            "coverage": {
                "mitre_techniques_referenced": mitre_coverage.get("enabled", 0),
>               "mitre_techniques_total": TOTAL_MITRE_TECHNIQUES,
                                          ^^^^^^^^^^^^^^^^^^^^^^
                "mitre_coverage_pct": (mitre_coverage.get("enabled", 0) / TOTAL_MITRE_TECHNIQUES * 100) if TOTAL_MITRE_TECHNIQUES > 0 else 0,
                "mitre_techniques_referenced_list": mitre_coverage.get("technique_list", []),
                "cis_controls_met": cis_coverage.get("met", 0),
                "cis_controls_total": len(CIS_CONTROLS),
                "cis_coverage_pct": cis_coverage.get("coverage_pct", 0.0),
                "ig1_coverage_pct": cis_coverage.get("ig1_pct", 0.0),
                "ig2_coverage_pct": cis_coverage.get("ig2_pct", 0.0),
                "ig3_coverage_pct": cis_coverage.get("ig3_pct", 0.0),
            }
        }
E       NameError: name 'TOTAL_MITRE_TECHNIQUES' is not defined

app\services\assessment.py:615: NameError
________________________ test_empty_findings_coverage _________________________

    def test_empty_findings_coverage():
        """Test coverage with no findings."""
        service = AssessmentService(MagicMock())
>       result = service._build_framework_mapping([])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

app\tests\test_framework_coverage.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.services.assessment.AssessmentService object at 0x0000020CB4AF2210>
findings = []

    def _build_framework_mapping(self, findings: List[Finding]) -> Dict[str, Any]:
        """Build framework mapping data (MITRE ATT&CK, CIS Controls, OWASP)."""
        from app.core.frameworks import (
            get_all_framework_refs,
            get_technique_coverage,
            get_cis_coverage_summary,
            MITRE_TECHNIQUES,
            CIS_CONTROLS,
        )
    
        mapped_findings = []
        for f in findings:
            refs = get_all_framework_refs(f.question_id) if f.question_id else {}
    
            mapped_findings.append({
                "finding_id": f.id,
                "title": f.title,
                "severity": get_severity_value(f.severity),
                "domain": f.domain_name,
                "mitre_refs": refs.get("mitre", []),
                "cis_refs": refs.get("cis", []),
                "owasp_refs": refs.get("owasp", []),
                "impact_score": 5,  # Default impact score
            })
    
        # Build coverage stats based on findings (gaps indicate missing controls)
        question_ids = [f.question_id for f in findings if f.question_id]
    
        # Simple coverage calculation
        # In a full implementation, we'd track which controls are implemented
        mitre_coverage = get_technique_coverage(question_ids) if question_ids else {}
        cis_coverage = get_cis_coverage_summary(question_ids) if question_ids else {}
    
        return {
            "findings": mapped_findings,
            "coverage": {
                "mitre_techniques_referenced": mitre_coverage.get("enabled", 0),
>               "mitre_techniques_total": TOTAL_MITRE_TECHNIQUES,
                                          ^^^^^^^^^^^^^^^^^^^^^^
                "mitre_coverage_pct": (mitre_coverage.get("enabled", 0) / TOTAL_MITRE_TECHNIQUES * 100) if TOTAL_MITRE_TECHNIQUES > 0 else 0,
                "mitre_techniques_referenced_list": mitre_coverage.get("technique_list", []),
                "cis_controls_met": cis_coverage.get("met", 0),
                "cis_controls_total": len(CIS_CONTROLS),
                "cis_coverage_pct": cis_coverage.get("coverage_pct", 0.0),
                "ig1_coverage_pct": cis_coverage.get("ig1_pct", 0.0),
                "ig2_coverage_pct": cis_coverage.get("ig2_pct", 0.0),
                "ig3_coverage_pct": cis_coverage.get("ig3_pct", 0.0),
            }
        }
E       NameError: name 'TOTAL_MITRE_TECHNIQUES' is not defined

app\services\assessment.py:615: NameError
============================== warnings summary ===============================
app\db\database.py:49
  P:\projects\AIRS\app\db\database.py:49: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

app\schemas\base.py:6
  P:\projects\AIRS\app\schemas\base.py:6: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class BaseSchema(BaseModel):

app\schemas\scoring.py:13
  P:\projects\AIRS\app\schemas\scoring.py:13: PydanticDeprecatedSince20: Using extra keyword arguments on `Field` is deprecated and will be removed. Use `json_schema_extra` instead. (Extra keys: 'example'). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    answers: Dict[str, Any] = Field(

app\schemas\organization.py:38
  P:\projects\AIRS\app\schemas\organization.py:38: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class OrganizationResponse(OrganizationBase):

app\schemas\assessment.py:56
  P:\projects\AIRS\app\schemas\assessment.py:56: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class AnswerResponse(BaseModel):

app\schemas\assessment.py:70
  P:\projects\AIRS\app\schemas\assessment.py:70: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ScoreResponse(BaseModel):

app\schemas\assessment.py:100
  P:\projects\AIRS\app\schemas\assessment.py:100: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FindingResponse(BaseModel):

app\schemas\assessment.py:144
  P:\projects\AIRS\app\schemas\assessment.py:144: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class AssessmentResponse(BaseModel):

app\schemas\assessment.py:170
  P:\projects\AIRS\app\schemas\assessment.py:170: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class AssessmentSummary(BaseModel):

app\schemas\report.py:91
  P:\projects\AIRS\app\schemas\report.py:91: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ReportResponse(BaseModel):

app\schemas\roadmap.py:29
  P:\projects\AIRS\app\schemas\roadmap.py:29: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class RoadmapItemResponse(RoadmapItemBase):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED app/tests/test_framework_coverage.py::test_mitre_coverage_calculation
FAILED app/tests/test_framework_coverage.py::test_empty_findings_coverage - N...
======================= 2 failed, 11 warnings in 0.43s ========================
